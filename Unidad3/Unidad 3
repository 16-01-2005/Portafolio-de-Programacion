 ğŸ“˜#Unidad 3: ProgramaciÃ³n Modular y Estructuras de Datos EstÃ¡ticas

> **DescripciÃ³n:** Comprender la importancia de dividir problemas complejos en subproblemas mÃ¡s pequeÃ±os (mÃ³dulos) y manejar colecciones de datos del mismo tipo de manera eficiente en memoria.

---

## ğŸ¯ Objetivos de la unidad

### ğŸ“¦ ProgramaciÃ³n Modular

* âœ… Concepto de "Divide y VencerÃ¡s".
* ğŸ§© DefiniciÃ³n y uso de Funciones/MÃ³dulos.
* ğŸ”„ Paso de parÃ¡metros y retorno de valores.

### ğŸ”¹ Estructuras de Datos EstÃ¡ticas

* ğŸ“Š Arreglos Unidimensionales (Vectores).
* â¬› Arreglos Bidimensionales (Matrices).
* ğŸ“¦ Arreglos Multidimensionales.
* ğŸ”¤ Cadenas de caracteres (Strings).

---

## ğŸ§© Temas Principales

### ğŸ“¦ ProgramaciÃ³n Modular: Conceptos y Uso

ğŸ“ **DefiniciÃ³n:** La programaciÃ³n modular es una tÃ©cnica de diseÃ±o de software que divide un programa grande en bloques independientes llamados mÃ³dulos o funciones.

ğŸ§¾ **AnalogÃ­a:** Funciona como una **fÃ¡brica de automÃ³viles**: en lugar de que una sola persona construya todo el coche, hay departamentos especializados (mÃ³dulos) que se encargan del motor, las ruedas y la pintura, para luego ensamblarlo.

> ğŸ’¡ **Nota:** La programaciÃ³n modular permite reutilizar cÃ³digo, facilitar la lectura y simplificar el mantenimiento del software.

#### Estructura bÃ¡sica en C

```c
// DeclaraciÃ³n (Prototipo)
tipo_retorno nombre_funcion(tipo_parametro parametro);

// DefiniciÃ³n
tipo_retorno nombre_funcion(tipo_parametro parametro) {
    // instrucciones del mÃ³dulo
    return valor;
}

```

#### âœ… CaracterÃ­sticas

* ğŸ—‚ï¸ **AbstracciÃ³n:** Permite concentrarse en *quÃ©* hace una funciÃ³n sin preocuparse por *cÃ³mo* lo hace internamente.
* ğŸ“ **ReutilizaciÃ³n:** Escribes el cÃ³digo una vez y lo llamas cuantas veces quieras.
* ğŸ”§ **Mantenibilidad:** Si hay un error, solo corriges el mÃ³dulo afectado, no todo el programa.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en C**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

### ğŸ“Š Arreglos Unidimensionales (Vectores)

ğŸ“ **DefiniciÃ³n:** Estructura de datos estÃ¡tica que almacena una secuencia de elementos del mismo tipo bajo un Ãºnico nombre.

âœ… **Funcionamiento:** Como una fila de casilleros numerados. Para encontrar un dato, solo necesitas saber el nÃºmero de casillero (Ã­ndice).

#### Estructura bÃ¡sica

```c
// tipo nombre_arreglo[tamaÃ±o];
int edades[10]; // Arreglo de 10 enteros

```

#### âœ… CaracterÃ­sticas

* ğŸ—‚ï¸ **Homogeneidad:** Todos los datos deben ser del mismo tipo (`int`, `float`, etc.).
* ğŸ“ **Ãndice:** Se accede mediante una posiciÃ³n numÃ©rica, comenzando siempre desde **0**.
* ğŸ“Œ **TamaÃ±o Fijo:** El tamaÃ±o se define al compilar y no puede cambiar.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en C**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

### â¬› Arreglos Bidimensionales (Matrices)

ğŸ“ **DefiniciÃ³n:** Estructura que organiza datos en dos dimensiones: **filas** y **columnas**.

âœ… **Funcionamiento:** Similar a una hoja de cÃ¡lculo o una sala de cine (Fila F, Asiento 5).

> ğŸ’¡ **Uso:** Ideales para tableros de juego, mapas, imÃ¡genes o relaciones matemÃ¡ticas.

#### Estructura bÃ¡sica

```c
// tipo nombre[filas][columnas];
int tablero[3][3];

```

#### âœ… CaracterÃ­sticas

* ğŸ—‚ï¸ **Acceso:** Se usa la sintaxis `matriz[i][j]`.
* ğŸ—ï¸ **Memoria:** Se guardan linealmente en memoria, fila tras fila.
* ğŸ” **Recorrido:** Usualmente requiere dos ciclos `for` anidados.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en C**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

### ğŸ“¦ Arreglos Multidimensionales

ğŸ“ **DefiniciÃ³n:** Arreglos con tres o mÃ¡s dimensiones.

ğŸ“¦ **AnalogÃ­a:** Si una matriz es una hoja, un arreglo 3D es un **libro** (muchas hojas), o un edificio (Piso, Pasillo, HabitaciÃ³n).

#### Estructura bÃ¡sica

```c
int cubo[3][3][3];

```

#### âœ… CaracterÃ­sticas

* ğŸ—‚ï¸ Requiere un Ã­ndice por cada dimensiÃ³n.
* ğŸ“ El consumo de memoria crece exponencialmente.
* ğŸ”§ Requiere alta abstracciÃ³n lÃ³gica.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en C**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

### ğŸ”¤ Cadenas o Strings

ğŸ“ **DefiniciÃ³n:** En C, es un arreglo de caracteres (`char`) diseÃ±ado para almacenar texto.

âœ… **Funcionamiento:** Es como un collar de cuentas (letras) que siempre termina con un "nudo" especial invisible: el carÃ¡cter nulo.

#### Estructura bÃ¡sica

```c
char saludo[] = "Hola";
// En memoria: ['H', 'o', 'l', 'a', '\0']

```

#### âœ… CaracterÃ­sticas

* ğŸ”€ **Terminador Nulo:** Debe terminar con `\0` para indicar el fin del texto.
* ğŸ—ï¸ **ManipulaciÃ³n:** Se usan funciones de la librerÃ­a `<string.h>` (ej. `strcpy`, `strlen`).
* âš ï¸ **Cuidado:** No se pueden asignar con `variable = "texto"` despuÃ©s de la declaraciÃ³n.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en C**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

## ğŸ§© Ejercicio en Java

ğŸ“Œ **Proyecto:** Sistema de GestiÃ³n de Notas Estudiantiles ğŸ“.

> **DescripciÃ³n:** El programa utiliza **ProgramaciÃ³n Modular** para separar la lÃ³gica de cÃ¡lculo. Usa un **arreglo unidimensional** para los nombres de los alumnos ğŸ§‘â€ğŸ“ y una **matriz** para sus calificaciones ğŸ“. Calcula promedios automÃ¡ticamente pasando los arreglos como parÃ¡metros.

**ğŸ§  Diagrama de Flujo** | **ğŸ“Œ CÃ³digo en Java**
--- | ---
*(Espacio para diagrama)* | *(Espacio para enlace o snippet)*

---

## âš ï¸ VerificaciÃ³n y ReflexiÃ³n

### âš ï¸ Principales Dificultades

âœ”ï¸ **Indices (Off-by-one):** Mi mayor dificultad es olvidar que los arreglos inician en 0, causando errores al intentar acceder a la posiciÃ³n `[tamaÃ±o]`.
âœ”ï¸ **VisualizaciÃ³n:** Me cuesta visualizar arreglos de mÃ¡s de 2 dimensiones.
âœ”ï¸ **ParÃ¡metros:** A veces confundo el paso por valor y por referencia.
âœ”ï¸ **Strings en C:** El manejo manual del carÃ¡cter `\0` suele causarme errores de memoria o "basura" en la impresiÃ³n.

### ğŸŒ€ ReflexiÃ³n CrÃ­tica

> ğŸ—‚ï¸ "La transiciÃ³n a estructuras de datos y modularidad marca un antes y un despuÃ©s en mi lÃ³gica. Entiendo que dividir un problema en funciones hace que sea mÃ¡s fÃ¡cil de resolver y mantener. Reconozco que dominar los arreglos es fundamental para bases de datos futuras. Necesito practicar mÃ¡s el **'dibujar' el problema en papel** (mapas de memoria) antes de codificar para visualizar mejor los Ã­ndices."

---

Â¿Te gustarÃ­a que desarrolle el cÃ³digo del ejercicio en Java o en C para que puedas incluirlo directamente en tu repositorio?
